# Задачи

## 1. Факториал (Решаем вместе)

*Факториалом* числа $n$ называют произведение $n$ первых положительных целых чисел. Факториал числа $n$ обозначается следующим образом: $n!$.

$$n! = \prod_{i=1}^{n}i$$

Давайте реализуем расчет факториала числа $n$ на `Python`. Сделать это можно с помощью цикла `while`:

```python
num = 5
factorial_of_num = 1

while 0 < num:
    factorial_of_num *= num
    num -= 1

print(f"{factorial_of_num = }")
```

Давайте разберем написанное по частям. В первой строке определяется переменная `num`. Это переменная соответствует числу $n$, чей факториал мы намерены рассчитать. Во второй строке мы определяем переменную `factorial_of_num`, в которой будет храниться рассчитанное значение факториала. В строках 4-6 происходит расчет факториала в цикле `while`. В условии цикла мы проверяем значение переменной `num`. Если `num > 1`, мы увеличиваем значение переменной `factorial_of_num` в `num` раз, а саму переменную `num` уменьшаем на `1`. Таким образом переменная `num` используется в качестве уменьшающегося счетчика. С ее помощью мы перечисляем все множители, принимающие участие в расчете факториала. В последней строке мы выводим отформатированный результат вычисления в стандартный поток вывода с помощью встроенной функции `print()`.

На самом деле реализовать расчет факториала на `Python` можно было бы гораздо эффективнее, используя другой цикл - цикл `for`. В отличие от цикла `while` цикл `for` выполняет определенное количество итераций, а не произвольное количество итераций, ограниченное истинностью условия цикла. В следующем примере, тело цикла `for` будет выполнено `3` раза:

```python
for i in range(3):
    print(i)
# Вывод:
# 0
# 1
# 2
```

В заголовке составной инструкции `for` происходит определение переменной `i`. Эта переменная называется *переменной цикла*. В качестве имени этой переменной не обязательно использовать `i`, можно использовать любое другое имя, которое подходит по контексту. На каждой итерации цикла с переменной цикла связывается новое значение, порождаемое *итерируемым объектов*. Об итерируемых объектах мы подробно поговорим позже. Сейчас достаточно знать, что итерируемые объекты могут быть использованы в цикле `for`.

Для отсчета определенного числа итераций используется специальный итерируемый объект `range`. На вход этому объекту необходимо передать целое число `n` - число итераций. Сам объект `range` позволяет произвести числа из полуинтервала $[0; n)$. Обращаем ваше внимание, что число $n$ в диапазон производимых значений не включено. Наибольшее число, производимое `range` - число $n - 1$. Также можно задать значение начального числа, производимого `range`:

```python
for i in range(1, 3):
    print(i)
# Вывод:
# 1
# 2
```

В этом случае `range` произведет числа из диапазона $[m; n)$, где $m$ - значение первого числа. О других особенностях работы с `range` мы поговорим в следующих занятиях.

Реализация факториала с помощью `range` будет выглядеть следующим образом:

```python
num = 5
factorial_of_num = 1

for i in range(1, num + 1):
    factorial_of_num *= i

print(f"{factorial_of_num = }")
```

Этот вариант предпочтительнее по нескольким причинам. Во-первых, цикл `for` выполняется быстрее из-за реализации интерпретатора. Во-вторых, вам не нужно беспокоиться за условие цикла и обновление значения счетчика - цикл `for` сделает все за вас. Тогда как в цикле `while` вам придется следить за всем самостоятельно.

## 2. Двойной факториал

**Условие**:

Помимо обычного факториала целого числа в математике также существует функция *двойного факториала* $n!!$, которая определяется следующим образом:

$$ n!! = 
\begin{cases}
n \times (n - 2)!!, n > 1\\
1, n \le 1
\end{cases}
$$

Ваша задача - реализовать расчет двойного факториала. Допишите код в файле [task2](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task2.py).

**Входные данные**:

- $n$ - целое положительное число меньшее или равное 20 или 0 - число, для которого нужно посчитать двойной факториал.

**Выходные данные**

- Целое положительное число - двойной факториал числа $n$.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 2 | 2 |
| 3 | 3 |
| 4 | 8 |

## 3. Вверх по лестнице

**Условие**:

Студент К. забирается вверх по лестнице. Лестница состоит из $n$ ступеней. Студент К. осторожный, поэтому на каждом шаге он поднимается вверх только на одну или две ступени. Но осторожность - не единственная положительная черта студента К. Еще одна положительная черта - любовь к алгоритмическим задачам. Студент К. решил определить, сколькими способами он сможете добраться до самого верха лестницы, если на каждом шаге он может делать или один, или два шага. Помогите студенту К. реализовать алгоритм подсчета количества способов подъема по лестнице.

Ваша задача - реализовать алгоритм расчета количества способов подъема по лестнице. Допишите код в файле [task3](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task3.py).

**Входные данные**:

- $n$ - целое число от 1 до 45 - число ступеней на лестнице.

**Выходные данные**

- Целое число, количество способов подъема по лестнице.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 3 | 3 |
| 4 | 5 |

## 4. Подсчет умножений

**Условие**:

При стандартном возведении в степень число умножается само на себя несколько раз. В результате, для вычисления $x^n$ нам необходимо $n$ операций умножения. К сожалению, операция умножения выполняется достаточно долго по сравнению с аддитивными операциями по типу сложения. Поэтому для ускорения программ люди начали искать алгоритмы вычисления степени числа с использованием меньшего количества операций умножения. Разберем один из самый простых вариантов алгоритма быстрого возведения в степень. В этом алгоритме мы будем использовать равенство $x^n = {(x^2)}^{\frac{n}{2}}$. В результате алгоритм будет формулироваться следующем образом:

- На вход поступает число $x$ и степень $n$;  
- Если степень делится нацело на 2, то вычисляем $x^2$, и ищем $x^2$ в степени $\frac{n}{2}$;  
- Если степень не делится нацело на 2, то вычисляем $x^{n-1}$, а потом умножаем получившееся число на $x$.

Таким образом, мы можем сильно уменьшить количество операций умножения в нашей программе, например, для вычисления $2^8$ вместо 8-ми умножений нам понадобится только 3: $2^2 = 4$, $4^2 = 16$ и $16^2 = 256$.

Ваша задача - реализовать алгоритм, который подсчитывает количество умножений при вычислении быстрого возведения в степень для заданной степени $n$. Допишите код в файле [task4](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task4.py).

**Входные данные**:

- $n$ - целое число от 1 до 1000 - степень числа.

**Выходные данные**

- Целое число - количество операций умножения, которое требуется для возведения числа в степень $n$ с помощью описанного алгоритма.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 8 | 3 |
| 10 | 4 |

## 5. НОД

**Условие**:

*Наибольшим общим делителем* (НОД) для двух целых чисел $m$ и $n$ называется наибольшее число, на которое $m$ и $n$ делятся без остатка. Есть множество алгоритмов поиска НОД. Один из самых популярных алгоритмов - это алгоритм Евклида. Он работает так:  

- На вход подаются 2 числа $m$ и $n$;  
- Берется остаток от деления большего из этих чисел на меньшее;  
- Если остаток равен 0, то меньшее число является НОД;  
- Если остаток не равен 0, то действия 1-3 повторяются для меньшего из чисел  $m$ и $n$ и полученного остатка;

Например, найдем НОД для чисел 1071 и 462:  

- остаток от деления 1071 на 462 равен 147;  
- остаток от деления 462 на 147 равен 21;  
- остаток от деления 147 на 21 равен 0;  
- НОД(1071, 462) равен 21.  

Ваша задача - реализовать алгоритм Евклида. Допишите код в файле [task5](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task5.py).

**Входные данные**:

- $n$ - целое положительное число число, меньшее или равное $10^{10}$;
- $m$ - целое положительное число число, меньшее или равное $10^{10}$;

**Выходные данные**

- Целое число - НОД чисел $n$ и $m$.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 1071<br>147| 21 |
| 13<br>17 | 1 |

## 6. Сумма простых делителей

**Условие**:

Простым делителем числа $n$ называется простое число, на которое $n$ делится без остатка. Найдите сумму всех простых делителей числа $n$ без повторений. Например, сумма простых делителей числа 12 равна 5.

Реализуйте алгоритм подсчета суммы простых делителей числа. Допишите код в файле [task6](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task6.py).

**Пояснения**:

- Простое число - это число, которое делится без остатка только на 1 и на само себя;  
- $12 = 2 \times 2 \times 3$. Простые множители без повторений: 2 и 3. $2 + 3 = 5$;

**Входные данные**:

- $n$ - натуральное число, меньшее или равное $10^{10}$.

**Выходные данные**

- Целое число - сумма простых делителей числа $n$.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 12 | 5 |
| 13 | 13 |
| 1 | 0 |

## 7. Число-палиндром

Число называется *палиндромом*, если оно читается слева направо точно так же как и справа налево.

Реализуйте алгоритм, который определяет является ли переданное число $n$ палиндромом или нет. Допишите код в файле [task7](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson02/task7.py).

**Входные данные**:

- $n$ - целое число от $-10^{10}$ до $10^{10}$.

**Выходные данные**

- Булево значение. `True`, если число является числом-палиндромом, `False` - иначе.

**Примеры**:

| Входные данные | Выходные данные |
|---|---|
| 121 | True |
| 13 | False |
