# Исключения

**Содержание**

- [Вступление](#вступление)
- [try-блок](#try-блок)
    - [try-except](#try-except)
    - [try-finally](#try-finally)
- [Механизм распространения ошибок](#механизм-распространения)
- [raise](#raise)
- [Иерархия исключений](#иерархия-исключений)

## Вступление

В демонстрационных примерах и вставках кода из предыдущих лекций мы неоднократно встречались с исключениями и механизмом их обработки. Сегодня пришло время детальней рассмотреть эту тему и разобраться с исключениями в Python.

Исключения в Python можно определить следующим образом - это объекты, которые сообщают об ошибках или об аномалиях. Когда интерпретатор Python сталкивается с какой-либо ошибкой, он возбуждает исключение, т.е. сообщает о возникновении нештатной ситуации, передавая исключение в механизм распространения ошибки (люди, знакомые с ML, привет).

Встроенные объекты языка могут самостоятельно порождать исключения, в зависимости от той или иной ситуации, однако в Python существует специальный механизм явного возбуждения исключений. Для этих целей служит специальный оператор `raise`, о чем мы подробнее поговорим ниже. 

Помимо возбуждения исключений, в Python, что логично, реализован механизм их обработки. Под обработкой исключений подразумевается их получение и осуществление необходимых мер для решения конкретных нештатных ситуаций. Обработка исключений позволяет предотвратить аварийное завершение программы с последующей трассировкой стека и выводом сообщения об ошибке.

Что интересно, Python использует исключения не только для индикации ошибок и аварийных ситуации, но и для индикации специальных событий. Так, например, объект `StopIteration`, который мы обсуждали, говоря об итерируемых объектах, является исключением, хотя формально всего лишь сообщает интерпретатору, что в процессе итерирования мы подошли к концу итератора.

Исходя из этого, стоит уделять особое внимание обработки исключений, и тщательно выбирать стратегию работы с различными ситуацийми, которые могут приводить к их появлению.

## try-блок

`try-блок` обеспечивает тот самый механизм обработки исключений в языке Python, о котором упомяналось в предыдущем разделе. Этот составноу утверждение существует в двух формах:

- инструкция try, за которой следует хотя бы одна инструкция `excpet` (и необязательно else);
- инструкция try, за которой слудет блок `finally`;  

### try-except

В общем виде try-except блок выглядит следующим образом:  
```python
try:
    do_dangerous_work()
except [expression [as target]]:
    handle_exception()
[else: 
    do_something()]
```

В квардратные скобки здесь заключены необязательные конструкции. Данная форма try-блока может иметь более одного except-блока. 

Тело каждого except-блока называется *обработчиком ошибок*. expression - класс-исключение (тип данных, производный от `BaseException`; подробнее об этом мы поговорим, разбирая классы), или кортеж, состоящий из классов исключений. Код внутри тела того или иного except-блока выполняется только в том случае, если тип исключения, возбужденного в теле try-блока, совпадает с  выражением except-блока. target - необязательный идентефикатор, с котором может быть связан порожденный в try-блоке и перехваченный except-блоком объект исключения. C помощью target перехваченный объект-исключение может быть использован в теле обработчика ошибок и даже возбужден повторно. 

Ниже приведен пример простого try-except блока:

```python
try:
    value = 1 / 0
except ZeroDivisionError:
    print('handle zero division')
```

Если try-except блок имеет несколько except-блоков, механизм распространения ошибки будет последовательно проверять совпадение типа возбужденного исключения с выражениями представленных except-блоков. Выполнено будет только тело первого совпавшего except-блока. 

*Пример*:
```python
my_dict = {}

try:
    value = my_dict['num'] / 0

except ZeroDivisionError:
    print('handle zero division')

except KeyError:
    print('handle key error')
```

В данном примере будет выполнен except-блок, соответсвующий исключению `KeyError`. Это произайдет, поскольку сначала интерпретатор попытается получить значение, лежащее в словаре под ключом 'num'. Поскольку данного ключа в словаре нет, возбуждается исключение KeyError, которое последовательно сопоставляется с положениями except-блоков. Исключение типа KeyError не относится к типу ZeroDivisionError, поэтому первый обработчик ошибок игнорируется. Во втором же случае, тип выражения в положении except-блока совпадает с типом возбужденного исключения, поэтому второй обработчик ошибок будет выполнен и на этом распространение ошибки завершится.

Последний except-блок может не содержать в себе никакого выражения. Такой обработчик будет работать со всеми исключениями, которые добирутся до него в процессе распространения ошибки. Подобные безусловные обработчики довольно редки и обычно встречаются в декораторах, где заранее низвестно, с каким типом исключений прийдется работать. 

*Совет*:

    Старайтесь избегать подобных безусловных обработчиков, используйте их только в том случае, если вы планируете повторно возбудить полученное исключение в их теле. В противном случае, вы рискуете столкнуться с проблемой слишком широкой обработки ошибок, которая скроет от вас действительно критические аномалии вашего кода и в разы усложнит процесс отладки.

Если ни один из указанных обработчиков ошибок не подойдет для обработки возбужденного исключения, исключение будет распространено дальше. Если try-блок вложен в другой try-блок (напрямую, или опосредованно, например, находясь в теле вызываемой функции), сначала будут проверены обработчики ошибок внутреннего блока, и если ни один из них не подойдет, исключение будет распространено на внешний блок. Этот факт стоит держать в голове, поскольку он может стать причиной нежелательного поведения.

*Пример*:
```python
try:
    try:
        value = 1 / 0

    except:
        print('handle all exceptions')

except ZeroDivisionError:
    print('handle zero division')
```

В данном примере исключение, возбужденное во внутреннем блоке, будет обработано внутренним except-блоком, посколько он является более общим, и не важно, что внешний блок является более подходящим для обработки возбужденного исключения. Соответсвенно, дальше исключение распространено не будет и тело внешнего обработчика ошибок не выполнится никогда. 

Данны пример приводит нас к следующему выводу:

    Всегда помещайте более специализированные обработчики ошибок до более общих. Ведь если поступить иначе, более общий обработчик будет экранировать собой более специализированный, что может приводить к неожиданным результатам.

*Пример*:
```python
my_dict = {}

try:
    try:
        value = my_dict['num'] / 0

    except ZeroDivisionError:
        print('handle zero division')

except KeyError:
    print('handle key error')
```

В данном примере, напротив, будет выполнен внешний блок-обработчик, поскольку тип возбужденного исключения не соответствует положению внутреннего обработчика.

Как упомяналось выше, try-except блок может завершаться необязательном else-блоком. В контексте обработки ошибок else-блок имеет то же значение, что и в контексте  [циклов](../lesson2/conspect.md). else-блок имеет скорее значение then и выполняется только в том случае, если тело try-блока выполнилось без возбуждения исключения, без прерывания и без операции возврата `return` (подробнее обсудим в разговоре о функциях). else-блок является достаточно полезным, и используется для выполнения блока кода, который зависит от операций, производимых в теле try-блока. 

*Неправильный пример*:

```python
try:
    value = 1 / my_dict['num']

except:
    print('handle exception')

print(f'{value = }')
```

Данные пример демонстрирует, насколько важен else-блок. Ведь, да, в случае возникновения исключения оно будет обработано, но переменная value не будет создана, и попытка вывести ее в функции print приведет к вызовову нового исключения. Гораздо правильнее было бы написать это следующим образом:

*Правильный пример*:
```python
try:
    value = my_dict['num']

except:
    print('handle exception')

else:
    print(f'{value = }')
```

В данном примере вывод значения value будет происходить только в том случае, если try-блок был выполнен без возбуждения какого-либо исключения. Иначе исключение будет обработано, а else-блок не будет выполнен.

### try-finally

В самом простом виде try-finally блок выглядит следующим образом:

```python
try:
    do_something()
finally:
    do_another_things()
```

Эта форма должна иметь всего одного инструкцию finally и не может иметь else-блока если отсутствуют обработчики ошибок.

finally-блок называется уборщиком (в оригинале clean-up handler). Код, который составляет тело уборщика выполняется вне зависимости от того, было ли возбуждено исключение или нет. Если в процессе распространения исключение было обработано, тело finally все равно будет выполнено, если - нет, finally-блок выполнится, но после него последует дальнейшее распространение ошибки. 

try-finally блок предлагает устойчивую и явную конструкцию для выполнения кода, который должен быть выполнен в любом случае. Обычно, в роли этого кода выступает освобождение некоторого ресурса: закрытие файлового дескриптора, закрытие подключения к базе данных или очистка UDP-сокета. Однако более безопасный и предпочтительный путь работы с подобными ресурcами - контекстные менеджеры.

*Пример использования finally*:

```python
file = open(path_to_file, 'w')

try:
    write_to_file(file, data)

finally:
    file.close()
```

*Пример использования контекстных менеджеров*:

```python
with open(path_to_file, 'w') as file:
    write_to_file(file, data)
```

Как было упомянуто выше, вы можете поместить обработчик ошибок в try-finally блок. В таком случае он будет иметь следующи вид:

```python
try:
    do_something()
except:
    handle_exception()
finally:
    clean_up()
```

Блок finally будет выполнен в любом случае, независимо от того, было обработано исключение или нет, а потому код из приведенного примера эквивалентен следующему коду:

```python
try:
    try:
        do_something()
    except:
        handle_exception()
finally:
    clean_up()
```

В try-finally блок может быть помещено несколько обработчиков исключений. Также, после обработчиков исключений, но до уборшика может быть помещен блок else. 


## Механизм распространения ошибок

Когда происходит возбуждение исключения, обычный поток выполнения программы прерывается, дальше контроль выполнения программы переходит к механизму обработки исключений. Интерпретатор Python начинает искать подходящий обработчик ошибок по принципу, изложенному выше. Возможные варианты обработки ошибок предоставляются try-блоком. Обработчики ошибок имеют дело как с исключениями, явно возбужденными в теле try-блока, так и с исключениями возбужденными неявным образом в телах функций, вызванных в try-блоке. Если в try-блоке определен обработчик ошибок, подходящий для обработки возбужденного исключения, осуществялется процедура обработки исключения, после чего механизм обработки исключения останавливается, поток выполнения программы продолжает свою работу с блоков кода, следующих за try-блоком.

Если утверждение, в ходе выполнения которого было возбуждено исключение, не имеет подходящего обработчика, исключение распространяется вверх по стеку вызова функций до тех пор пока не будет найден подходящий обработчик. В случае, если стек вызовов будет исчерапан, а подходящий обработчки так и не будет найден, программа будет аварийно завершена. Аварийное завершение сопровождается трассеровкой стека, содержащей детальную информацию о местах в коде, спровоцировавших возбуждение исключения, и вывода сообщения об ошибке. 

Ниже приведен небольшой пример, иллюстрирующий описанный принцип:

```python
def f():
    print('in f, before 1/0')
    1/0 
    print('in f, after 1/0')

def g():
    print('in g, before f()')
    f()
    print('in g, after f()')

def h():
    print('in h, before g()')
    try:
        g()
        print('in h, after g()')
    except ZeroDivisionError:
        print('ZD exception caught')
    print('function h ends')
```

*Вывод*:
```console
in h, before g()
in g, before f()
in f, before 1/0
ZD exception caught
function h ends
```

## raise

Положение raise используется для явного возбуждения raise. В общем случае raise имеет следующий синтаксис:

```python
raise [expression]
```

Осуществлять вызов raise без выражений могут только обработчики исключений. Данный синтаксис соответствует повторному возбуждению исключения, полученного обработчиком. В этот момент выполнение тела обработчика прерывается, а механизм распространения ошибки возобновляет свою работу. Подобный вариант использования raise может быть полезен, когда обработка исключения подразумевает, например, освобождение некоторого ресурса, но не подразумевает прекращение распространения ошибки.

Если же выражение присутствует, оно должно иметь тип исключения (или быть наследником BaseException, но этот разговор мы прибережем до прохождения темы ООП).

*Пример*:

```python
def cross_product(seq1, seq2):
    if not seq1 or not seq2:
        raise ValueError("sequence should 't be empty")

    return [(x1, x2) for x1 in seq1 for x2 in seq2]
```

После возбуждения исключения ответственность за его распространение или обработку ложится на вызывающею сторону.

*Совет*:

    Используйте raise только для возбуждения дополнительных исключений, т.е. в тех случаях, когда неявного возбуждения исключений со стороны интерпретатора не происходило бы. Не стоит использовать raise для вызова тех исключений, которые были бы возбуждены интерпретатором в любом случае.

## Иерархия исключений

В данном разделе будет изложена только самая общая информация об иерархии исключений в Python. За подробностями по мере необходимости лучше обращаться напрямую к [документации](https://docs.python.org/3.11/library/exceptions.html).

Самый общий класс ошибок, который является родителем для прочих исключений - класс `BaseException`. Он не используется напрямую, только для создания новых классов ошибок. 

BaseException имеет четыре дочерних класса:

- `Exception` - класс, который обобщает все остальные исключения, типа KerError, ZeroDivisionError и т.д.;  
- `GeneratorError` - специальное исключение, которое используется для возвращения значений из сопрограмм;  
- `KeyboardInterrupt` - специальное исключение, которое возбуждается после прерывания программы с помощью клавиш ctrl+C; 
- `SystemExit` - вызывается функцией `sys.exit()` для остановки работы интерпретатора;

