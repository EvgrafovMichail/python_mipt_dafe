# Типы данных: числа, списки, кортежи

**Содержание:**

- [Общие сведения о типах данных](#общие-сведения-о-типах-данных)
- [Числовые типы данных](#числовые-типы-данных)
    - [Целочисленные литералы](#целочисленные-литералы)
    - [Литералы чисел с плавающей точкой](#литералы-чисел-с-плавающей-точкой)
    - [Литералы комплексных числе](#литералы-комплексных-чисел)
    - [Логический тип данных](#логический-тип-данных)
    - [Преобразования цичловых типов](#преобразования-числовых-типов)
    - [Арифметические операции](#арифметические-операции)
    - [Логические операции](#логические-операции)
    - [Битовые операции](#битовые-операции)
- [Последовательности и итерируемые объекты](#последовательности-и-итерируемые-объекты)
- [Операции над последовательностями](#операции-над-последовательностями)
- [Кортежи](#кортежи)
- [Списки](#списки)

## Общие сведения о типах данных

Как нам известно из [прошлой лекции](../lesson2/conspect.md
), в Python существуют переменные. Переменные являются ссылками на некоторые данные в памяти компьютера. Данные, на которые ссылаются переменные, называются *объектами* (objects). В отличие от переменных, которые не являются типизированными, объекты имеют строго заданный тип данных. Тип данных определяет значения, которые может принимать данный объект, набор операций, поддерживаемых данным объектом, его атрибуты, поддерживает ли объект хранение элементов, и какие ограничения накладываются на элементы, если поддерживает.

Все типы данных в Python делятся на две основные группы: изменяемые (*mutable*) и неизменяемые (*immutable*). Объекты изменяемых типов данных могут менять свое значение в процессе выполнения программы. Объекты неизменяемых - не могут.

Для определения типа данных объекта, с которым связана та или иная переменная, в Python существует специальная функция `type()`, принимающая на вход объект Python.

*Код:*
```Python
num = 5
print(type(5), type(5).__name__, sep='\n')
```

*Вывод:*
```Console
<class 'int'>
int
```
В Python реализованы основные типы данных: числа, стоки, кортежи, списки, множества и словари. Также при необходимости пользователь может самостоятельно определить свой тип данных, называемый *классом*. Но это тема совершенно другой лекции.

## Числовые типы данных

В Python реализованы следующие числовые типы данных: целые числа, числа с плавающей точкой и комплексные числа. Также для работы с числами в стандартной библиотеки Python существуют модули `decimal` и `fractions`, но они в рамках нашего курса обсуждаться не будут. 

Числовые типы данных являются неизменяемыми. Отсюда следует, что почти любые операции над числами приводят к созданию нового объекта числового типа данных и его аллокации в памяти компьюетра. Мы говорим "почти", так как Python заранее аллоцирует в памяти объекты типа int, чье значение лежит в диапазоне от -5 до 256. Таким образом, если результатом операции над числами будет являться целое число в указанном диапазоне, создание нового объекта происходить не будет. Все, что сделает интерпретатор - перепривяжет идентефикатор.

*Пример 1*:
```Python
num = 1
print(id(num))

num += 5
print(id(num))
```
*Результат*:
```Console
140706836767528
140706836767688
```

*Пример 2*:

```Python
num1 = 5
num2 = 10
num3 = 5

print(id(num1) == id(num2 - num3) == id(num3))
```

*Результат*:
```Console
True
```

*Пример 3*:
```Python
num1 = 500
num2 = 1000
num3 = 500

print(
    id(num1) == id(num3),
    id(num1) == id(num2 - num3),
    id(num3) == id(num2 - num1),
    sep='\n'
)
```

*Результат*:
```Console
False
False
False
```

### Целочисленные литералы

Для начала обсудим целочисленные литералы. В Python целочисленные литералы могут иметь десятичный, двоичный, восмеричный и шестнадцатеричный вид. 

*Пример целочисленных литералов:*

```Python
1, 23, 4567     # десятичные литералы
0b101, 0b11011  # двоичные литералы
0o1, 0o6645     # восьмеричные литералы
0x1, 0xDA5      # шестандцатеричные литералы
```

Также для читабельности числовых литералов вы можете разделять разряды с помощью нижнего подчеркивания. Эта информация в равной степени применима ко всем числовым типам данных.

*Пример использования разделителей:*
```Python
1_000_000_000
0xF1c5_910D_FF0A
```

В отличие от языков программирования типа C и C++ максимальное (и минимальное) значение целочисленного типа данных не имеет заранее обговоренного ограничения и упирается в количество свободной памяти компьютера. С одной стороны, это является плюсом, т.к. при работе с Python вы не будете задаваться вопросами о переполнении даже при работе с очень большими числами (см. длинная арифметика), с другой стороны, особенности хранения целых чисел, позволяющие проворачивать подобное, накладывают заметные ограничения на производительность.

### Литералы чисел с плавающей точкой

Литералы чисел с плавающей точкой представляют собой последовательность десятичных чисел, включающую точку, суффикс экспоненты (символ e, за которым опционально следует знак и как минимум одна десятичная цифра) или и точку, и суффикс. Первым символом числа с плавающе точкой не может быть символ экспоненты, им может быть или цифра, или точка.

*Примеры литералов*:

```Python
0.      0.0     .0
1.      1.0      1e0      1.e0
```

Числа с плавающей точкой в Python являются аналогом чисел с плавающей точкой в С: они имеют те же ограничения, ту же точность, а их значения хранятся аналогичным образом.

### Литералы комплексных чисел

Комплексные числа представляют собой алгебраическую сумму реального числа с плавающей точкой с мнимым числом с плавающей точкой. Доступ к мнимой и реальной части комплексного числа осуществляется через атрибуты чтения `.real` и `.imag`.

*Примеры литералов:*

```Python
0j      0.j     0.0j      .0j
1j      1.j     1.0j      1e0j
1.e0j   1.0e0j
```

### Логический тип данных

Формально, логический тип является отдельным типом данных. Однако, фактически, он является подклассом типа `int`, т.е. целых чисел. Булевый тип данных имеет всего два значения: правда и ложь. Для этих значений существуют специальные константы-синглтоны `True` и `False`, соответственно, которые также имеют свои числовые эквиваленты: 1 и 0. Почти любые данные в Python могут быть представлены булевым значением: любое число, отличное от 0 в булевом контексте принимает значение True, любая непусткая коллекция также принимает значение True. 0, пустая коллекция и синглтон `None` принимают значение False.

Также вы можете преобразовать данные в булево значение явным образом, используя функцию `bool()`. Однако данная практика не рекомендована, поскольку python-way - это неявное преобразование данных к логическому типу в булевом контексте.

*Пример*:
```Python
# рекомендованный стиль
if x:
    ...

# нежелательный стиль
if bool(x):
    ...
```

### Преобразования числовых типов

В Python вы можете осуществлять арифметические и логические операции между значениями любых числовых типов данных. В случае, если операнды имеют различные числовые типы данных, Python осуществит неявное преобразование  операнда с "меньшим" типом данных к "большему" типу данных. Числовые типы данных в порядке от "меньшего" типа, к "большему": целые числа, числа с плавающей точкой, комплексные числа. В случае необходимости вы также можете осуществить явное преобразование типов, используя встроенные функции `int()`, `float()` и `complex()`. Функция complex() принимает на вход два числа: действительную и мнимую часть. Также комплексные числа не могут быть преобразованы в целые числа или числа с плавающей точкой напрямую, из-за неоднозначности преобразования.

Функция int() отбрасывает дробную часть, в случае ее наличия. Также, в отличие от других функций, int() может быть вызвана с двумя аргументами - строка, содержащая в себе число, и основание системы счисление - число от 2 до 36. Для систем счисления с основанием большим 10 необходимо использовать соответствующие буквы англиского алфавита для обозначения цифр.

*Пример*:
```Python
print(int('abba'), 36)
```
*Вывод*:
```
481222
```

Помимо объектов числовых типов данных, функции int(), float() и complex() могут принимать на вход строки, содержащие допустимые числовые литералы, знак числа, а также ведущие и завершающие пробелы.

### Арифметические операции

В целом, числовые типы данных поддерживают классический набор арифметически операций, которые работают очевидным образом. Однако мы уделим отдельное внимание делению.

В Python существует три вида операций деления: истинное деление (/), целочисленное деление (//) и модульное деление (%). Результатом истинного деления будет число типа float, даже если оба операнда были целыми числами. Однако, если вы хотите себя обезопасить и написать программу, обратно совместимую с программами, написанными на Python v2, используйте преобразование одного из операндов к типу float.

*Пример*:
```Python
num1 = 1
num2 = 2

# чуть медленнее
float(num1) / num2

# чуть быстрее
1.0 * num1 / num2
```

Результат целочисленного деления - целая часть от деления, модульного - остаток. Для получения и целой, и дробной части в одно действие, вы можете использовать встроенную функцию `divmod()`.

Для возведения в степень используется бинарная операция ** или втроенная функция `pow()`.

*Примеры возведения в степень*:
```Python
print(3 ** 4)
print(pow(3, 4))
print(pow(3, 4, 8))     # (3 ** 4) % 8
```

*Вывод*:
```Python
81
81
1
```

### Логические операции

Числовые типы данных могут быть использованы с логическими операндами. Сравнение на равенство/неравенство применимо ко всем числовым типам данных. Логические операции порядка (<, <=,>, >=) могут быть использованы только с некомплексными числами, в противном случае будет вызываться исключение.

Результатом выполнения логических операций является булево значение. Также логические операции могут объединяться в сложные логические выражения с помощью бинарных операторов `and` и `or`.
Операторы and и or являются "ленивыми": второй аргумент оператора and вычисляется только в том случае, когда первый принимает значение True; второй аргумент оператора or вычисляется только если первый принимает значение False.

Также сложные условия могут заменяться на последовательность логических операторов.

*Пример:*

```Python
a, b, c = 1, 2, 3

# сложное условие
if a < b and b < c:
    ...

# последовательность операторов
if a < b < c: # a < b and b < c:
    ...

```

### Битовые операции

Целые числа поддерживают битовые операции: сдвиг (<<, >>), инверсия (~), битовое и (&), битовое или (|), не или (^).

## Последовательности и итерируемые объекты

Одной из базовых концепций Python явялется концепция *итерируемого объекта*. Мы уже встречались с итерируемыми объектами, когда обсуждали цикл for, тогда мы ограничились тем, что итерируемый объект - это объект, чьи элементы можно перебрать в цикле. Если подойти к этому вопросу формальнее, то итерируемый объект в Python - это объект, который поддерживает вызов функции `iter()`, пораждающий итератор. Итератор же - это объект, с которым поддерживается вызов функции `next(i)`, где i - итератор. Каждый вызов функции iter(i) возвращает новое значение, хранящееся (коллекции) или вычисляемое (генераторы) в итераторе. Все итераторы делятся на ограниченные и неограниченные. Ограниченные итераторы способны вернуть конечное число элементов, после определенного числа вызовов функции next(i) ограниченные итераторы вызывают исключение `StopIteration`, сигнализирующее о завершении элементов. Неограниченные итераторы поддерживают неограниченное количество вызовов функции next(i). Для получения итератора в Python используется функция `iter()`.

Итерируемые объекты - очень общая концепция, которая включает в себя большое количество различных классов объектов. К числу таких классов относятся последовательности.

В Python под последовательностями подразумевается упорядоченная коллекция, индексируемая целыми числами. Последовательности реализуют специальные методы `__len__()` (определение количества элементов) и `__getitem__()` (доступ к элементу через [ ]). Последовательности являются итерируемыми объектами, но обратное неверно: не все итерируемые объекты являются последовательностями. 

Исходя из всего вышесказанного становится понятна логика работы цикла for:

```Python
# исходный код
for i in iterable:
    do_something(i)

# логика работы
_iterator = iter(iterable)
while True:
    # блок для обработки исключений
    try:
        i = next(_iterator)
    # обрабатываем только StopIteration
    except StopIteration:
        break
    do_something(i)
```

К последовательностям в Python относятся кортежи, списки и строки. В этой лекции речь пойдет о кортежах и списках.

## Операции над последовательностями

Прежде чем переходить к детальному рассмотрению представителей последовательностей обсудим набор операций, свойственных для всех последовательностей.

### Конкатенация и повторение


Вы можете конкатенировать последовательности одного типа, используя оператор +. Также вы можете повторять последовательность n раз, умножая последовательность на целое число справа или слева. Повторение последовательности n раз эквивалентно последовательной конкатенации n одинаковых последовательностей.

### Проверка вхождения

С помощью ператора `in` вы можете проверить является ли какой-либо объект Python элементом последовательности. Оператор возвращает True, если является и False иначе. Существует две формы отрацания этого оператора, описанные в примере.

*Пример:*
```Python
array = list(range(5))
num = 3

print(num in array)         # проверка вхождения
print(not(num in array))    # отрицания
print(num not in array)     # еще одна форма отрицания
```

### Индексация

Вы можете обращаться к элементам последовательности по целочисленном индексу:

*Пример*:
```Python
sequence = [1, 2, 3, 4]
print(sequence[2])
```

*Вывод*:
```Console
3
```
Индексация начинается с нуля и осуществляется через квадратные скобочки. Индекс может принимать значения от 1 до n, где n - длина последовательности. Также индексы могут принимать отрицательные значения от -1 до -n. Отрицательные индексы можно воспринимать как индекс n + i, где i - отрицательный индекс. Таким образом индексу -1 соответствует n-1 элемент последовательности, -2 - n-2 и т.д. Если индекс принимает значение большее n-1 или меньшее -n, вызывается исключение выххода индекса за границы массива.

### Срезы

Также в можете получить подпоследовательность элементов последовательности, используя *срезы*. Срезы в Python - это полноценные объекты, которые можно создать следующим образом:

```Python
slice(start, stop, step)
```

где start - индекс начала подпоследовательности, stop - индекс конца подпоследовательности, step - шаг. stop в результирующую подпоследовательность не включается. Но таким синтаксисом почти не пользуются. В контексте индексации объект среза конструируется неявно. Индексация с помощью среза выглядит так:

```Python
array = [1, 2, 3, 4, 5]

print(arr[1:3])
print(arr[:3])
print(arr[1:])
print(arr[::2])
print(arr[::-1])
print(arr[-2:-5:-1])
```

*Вывод*:
```Console
[2, 3]
[1, 2, 3]
[2, 3, 4, 5]
[1, 3, 5]
[5, 4, 3, 2, 1]
[4, 3, 2]
```

## Кортежи

Кортеж (tuple) - неизменяемая упорядоченная последовательность элементов. Элементы кортежа - независмые объекты различных типов. Несмотря на то, что кортеж - неизменяемый тип данных, вы можете использовать объекты изменяемых типов данных в качестве элементов кортежа и изменять их. Однако пользоваться подобной практикой крайне не рекомендуется. Старайтесь избегать использования изменяемых объектов в качестве элементов кортежа.

Для объявления кортежа используйте ряд выражений, разграниченных запятыми. Вы также можете поместить выражения, разделенные запятыми в круглые скобки, но это необходимо только в том случае, когда разделение только лишь запятыми не может быть однозначно воспринято интерпретатором, или если вы хотите создать пустой кортеж. Также вы можете создать кортеж, добавив запятую после выражения.

*Пример создания кортежа*:

```Python
(1, 2, 3)
1, 2, 3
(3.14, )
3.14, 
()
```

Вы также можете создать кортеж с помощью втроенной функции `tuple()`. На вход требуется любой итерируемый объект. Вызов функции без аргументов приведет к созданию пустого кортежа.

*Пример использования tuple*:

```Python
tuple('hello')
tuple()
```

*Вывод*:
```Console
('h', 'e', 'l', 'l', 'o')
()
```

Кортежи поддерживают все операции над последовательностями. Результат конкатенации и срезки - новый кортеж. Из неизменяемость следует невозможность перезаписи элементов кортежа. 

Помимо обозначенных операций, кортеж имеет два строенных метода: `index()` и `count()`. Метод индекс принимает на вход объект Python и возвращает индекс первого его вхождения вкортеж, если он есть в коллекции, иначе - ValueError. Метод count() принимает на вход объект Python и подсчитывает количество его вхождений в кортеж. 

*Пример*:
```Python
numbers = tuple(range(5)) * 2

print(numbers
)
print(numbers.count(3))
print(numbers.count(42))
print(numbers.index(3))
print(numbers.index(42))
```
*Вывод*:
```Console
(0, 1, 2, 3, 4, 0, 1, 2, 3, 4)
2
0
3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: tuple.index(x): x not in tuple
```

## Списки

Список - изменяемая упорядоченная последовательность элементов. Элементы списка - независимые эобъекты различных типов данных. Для определения списка испульзуется ряд выражений, разделенных запятыми и помещенных в квадратные скобки. 

*Примеры объявления списков*:

```Python
[42, 3.14, 'string']
[100]
[]
```
По аналогии с кортежем, список может быть создан из любого итерируемого объекта с помощью функции `list()`. Вызов функции без аргументов приведет к созданию пустого списка.

*Пример использования list*:

```Python
list('hello')
list()
```

*Вывод*:
```Console
['h', 'e', 'l', 'l', 'o']
[]
```

Списки поддерживают все операции, свойственные последовательностям.

### Изменения через индексацию

Поскольку списки - изменяемые объекты, вы можете изменять значения их элементов, используя индексацию , удалять или добавлять новые элементы используя срезы.

*Примеры изменения содержимого*:
```Python
nums = [1, 2, 3, 4, 5]
nums[1] = 42                # [1, 42, 3, 4, 5]
nums[2:4] = [5, 6, 7, 8]    # [1, 42, 5, 6, 7, 8, 5]
nums[2:2] = [3, 3, 3]       # [1, 42, 3, 3, 3, 5, 6, 7, 8, 5]
nums[2:7] = []              # [1, 42, 7, 8, 5]
nums[:] = [1]               # [1]

```

### Операции на месте

Для списков составное присваивание типа *= и += не будут создавать новый объект, а будут модифицировать имеющийся список.

### Методы

Списки имеют модифицирующие и немодифицирующие методы. К немодифицирующим методам относятся метод index() и метод count(), которые работают аналогичено соответствующим методам кортежей. Ниже представлены модифицирующие методы списков, который изменяют текущий объект.

|Сигнатура|Описание|
|--|--|
|append(x)|добавляет элемент x в конец списка|
|extend(x)|добавляет все элементы из итерируемого объекта x в конец списка|
|insert(i, x)|вставляет элемент x перед элементом с индексом i|
|remove(x)|удаляет из списка первое вхождение элемента x|
|pop(i=-1)|возвращает элемент под индексом i и удаляет его из списка; удаляет последний элемент, если значние i опущено; если список пуст или i - недействительный индекс, вызывает исключение|
|reverse()|разворачивает список на месте|
|sort(key=None, reverse=False)|сортирует список на месте|
___
